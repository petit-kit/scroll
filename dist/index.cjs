"use strict";function t(t,s,e,i,n,o=!1){const r=s.parentElement.offsetTop,h=s.offsetHeight,a=window.innerHeight,u=c(s.style.transform),l=n[1]*a-u.y,p=n[3]*a-u.y,d=s.offsetTop-e-i+r-l,m=t.offsetWidth;if(o)return`0 ${d}px,${m}px ${d}px,${m}px ${d+h}px,0 ${d+h}px`;{const t=s.offsetTop+s.offsetHeight-i+r-p;return`0 ${d}px,0 ${t}px,0 ${d}px,${m}px ${d}px,${m}px ${t}px,0 ${t}px`}}var s,e=Object.defineProperty,i=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,r={};((t,s)=>{for(var i in s)e(t,i,{get:s[i],enumerable:!0})})(r,{default:()=>$,intersection:()=>x,mask:()=>f,scrollbar:()=>y,speed:()=>b,sticky:()=>m}),module.exports=(s=r,((t,s,r,h)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let r of n(s))o.call(t,r)||undefined===r||e(t,r,{get:()=>s[r],enumerable:!(h=i(s,r))||h.enumerable});return t})(e({},"__esModule",{value:!0}),s));var h=require("@petit-kit/utils"),a=class{constructor(t,s=.25){this._bounds={start:0,end:0},this._inertia=0,this._values=[],this._current=t,this._target=t,this._lerp=s,this._originLerp=s}shouldTick(){const t=this._current-(this._target+this._inertia);return Math.abs(t)>.1}setCurrent(t){this._current=t}setBounds(t,s){this._bounds={start:t,end:s},this._current=(0,h.clamp)(this._bounds.start,this._current,this._bounds.end),this._target=(0,h.clamp)(this._bounds.start,this._target,this._bounds.end)}setTarget(t,s=this._originLerp){this._target=(0,h.clamp)(this._bounds.start,t,this._bounds.end),this._lerp=s}setDelta(t,s=this._originLerp){this.setTarget(this._target+t,s)}tick(){return this._inertia*=.955,this._target+=this._inertia,this._current+=(this._target-this._current)*this._lerp,this._current=(0,h.clamp)(this._bounds.start,this._current,this._bounds.end),this._current}resetInertia(){this._inertia=0,this._values=[]}incrementInertia(t){this._values.push(t),this._values.length>5&&this._values.shift()}computeInertia(){this._inertia=this._values.length?(0,h.sum)(this._values)/this._values.length:0}getTarget(){return this._target}getCurrent(){return this._current}getBounds(){return this._bounds}getProgress(){return this._current/(this._bounds.end-this._bounds.start)||0}},c=t=>t.includes("translate3d")?u(t):t.includes("translateX")?p(t):t.includes("translateY")?d(t):t.includes("translate")?l(t):{x:0,y:0},u=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate3d(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},l=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},p=t=>({x:parseFloat(t.replace("translateX(","")),y:0}),d=t=>({x:0,y:parseFloat(t.replace("translateY(",""))}),m=function(t){function s(t){const s=Object.assign({willChange:!0},t.opts),e=s.willChange;return s.parent&&(s.parent.style.position="relative"),e&&(t.element.style.willChange.includes("transform")||(t.element.style.willChange+=" transform")),t.element.oldTransform||(t.element.oldTransform=c(t.element.style.transform)),e=>{const{element:i}=t,n=s.parent||e.getRoot(),o=(s.offset||e.getOffsets())[1]*window.innerHeight,r=i.offsetTop+n.offsetTop+i.oldTransform.y,h=n.offsetTop+(n.offsetHeight-o)-i.offsetHeight;let a=r-o-e.getCurrent().y;a=Math.min(a,0),a-=Math.min(0,h-e.getCurrent().y);let c=0;c=-a;const u=((t,s,e=!1)=>({x:t.x+(e?-s.x:s.x),y:t.y+(e?-s.y:s.y)}))({x:0,y:c},i.oldTransform,!1);i.style.transform=`translate3D(${u.x}px, ${u.y}px, 0px)`}}t.sticky=(e,i)=>{t.trigger(e,s,i)}},w=require("@petit-kit/utils"),x=function(t){t.intersection=(s,e)=>{t.trigger(s,function(t){return s=>e=>{const{element:i}=s,n=i.getBoundingClientRect(),{width:o,height:r,top:h,left:a}=n,c=window.innerHeight,u=e.getCurrent().y,l=s.opts.offset||e.getOffsets(),p=l[1]*c,d=l[3]*c,m=(0,w.clamp)(0,-a/o,1),x=(0,w.clamp)(0,-(h-p)/r,1),b=(i.offsetTop-(u+c-d))/r,f=1+(i.offsetTop-(u+p))/r,g=Math.min(r,c-(p+d))/r,y=(0,w.clamp)(0,Math.min(-b,Math.min(g,f)),1);t({intersection:{x:m,y:x||-(0,w.clamp)(0,1-(u+c-i.offsetTop-d)/r,1),top:x,bottom:b},overlapping:{x:1-Math.abs(m),y},bb:n})}}(e))}},b=function(t){function s(t){const{speed:s=1,centered:e=!0}=t.opts||{};return i=>{const{element:n}=t,o=i.getCurrent().y,r=e?(n.offsetTop-o-window.innerHeight/2)*s:o*s;n.style.transform=`translate3D(0, ${r}px, 0)`}}t.speed=(e,i)=>{t.trigger(e,s,{...i,forever:!0})}},f=function(s){function e(s){const{invert:e=!1,targets:i}=s.opts||{};return s.element.style.willChange&&(s.element.style.willChange=s.element.style.willChange+" clipPath"),n=>{const{element:o}=s,r=o.offsetTop,h=n.getOffsets(),a=n.getRoot(),c=a.offsetWidth,u=a.offsetHeight;if(e){const s=i.map((s=>t(n.getRoot(),s,r,n.getCurrent().y,h,!0)));o.style.clipPath=`polygon(${s.join(",")})`}else{const s=`polygon(0% 0%, ${i.map((s=>t(n.getRoot(),s,r,n.getCurrent().y,h,!1))).join(",")}, 0 ${u}px,${c}px ${u}px,${c}px 0%)`;o.style.clipPath=s}}}s.mask=(t,i,n=!1)=>{const o=Array.isArray(i)?i:[i];s.trigger(t,e,{targets:o,invert:n,forever:!0})}},g=require("@petit-kit/utils"),y=function(t={scrollBar:{},scrollBarThumb:{},inactiveOpacity:.2,activeOpacity:1}){const s={inactiveOpacity:t.inactiveOpacity||.25,activeOpacity:t.activeOpacity||1,scrollBar:{position:"fixed",zIndex:2e3,top:0,right:"0px",width:"9px",height:"100%",backgroundColor:"transparent",transition:"width 0.25s ease-in-out, background-color 0.25s ease-in-out",...t.scrollBar},scrollBarThumb:{position:"absolute",top:0,left:0,width:"calc(100% - 4px)",height:"calc(100% - 2px)",backgroundColor:"#babac0",borderRadius:"10px",marginLeft:"2px",boxShadow:"0 0 10px 0 rgba(0, 0, 0, 0.2)",transition:"opacity 0.5s ease-in-out, background-color 0.5s ease-in-out",cursor:"grab",opacity:0,...t.scrollBarThumb}},e=`<div id="ptk-scroll-bar" style="${(0,g.objectToStyle)(s.scrollBar)}">\n    <div class="ptk-scroll-bar-thumb" style="${(0,g.objectToStyle)(s.scrollBarThumb)}"></div>\n  </div>`;document.body.insertAdjacentHTML("beforeend",e);const i=document.body.querySelector("#ptk-scroll-bar"),n=i?.querySelector(".ptk-scroll-bar-thumb");let o,r=!1,h=!1;const a=()=>{h||(i.style.backgroundColor="transparent",n.style.opacity=`${s.inactiveOpacity}`,i.style.width=s.scrollBar.width)},c=(0,g.debounce)(a,500),u=()=>{r||(h=!1,c(),a())};(0,g.addEvent)(i,"mouseenter",(()=>{i.style.backgroundColor=(0,g.hexToRgba)(s.scrollBarThumb.backgroundColor,.15),n.style.opacity=`${s.activeOpacity}`,i.style.width="12px",h=!0})),(0,g.addEvent)(i,"mouseleave",u);const l=t=>{t.preventDefault(),t.stopPropagation(),t.stopImmediatePropagation(),r=!1,h=!1,n.style.cursor="grab",document.body.style.cursor="default",document.body.style.userSelect="auto",u(),window.removeEventListener("mouseup",l),window.removeEventListener("mousemove",o),setTimeout((()=>{p=!1}),1)};let p=!1,d=0,m=0;(0,g.addEvent)(n,"mousedown",(t=>{p=!0,r=!0,h=!0;const s=n.getBoundingClientRect();d=t.clientY-s.top,m=s.height-d,n.style.cursor="grabbing",document.body.style.cursor="grabbing",document.body.style.userSelect="none",window.addEventListener("mouseup",l,{passive:!1}),window.addEventListener("mousemove",o),i.removeEventListener("click",w)}));const w=t=>{t.relatedTarget||t.toElement||l(t)};document.addEventListener("mouseout",w);let x=()=>{};return i.addEventListener("click",(t=>{p||x(t)})),function(t){const s=document.querySelector("#ptk-scroll-bar"),e=s?.querySelector(".ptk-scroll-bar-thumb");x=s=>{const e=t.getBounds(),i=(0,g.mapRangeClamp)(0,window.innerHeight,s.clientY,e.y.start,e.y.end);window.scrollTo(0,i)},o=s=>{const e=t.getBounds(),i=(0,g.mapRangeClamp)(d,window.innerHeight-m,s.clientY,e.y.start,e.y.end);window.scrollTo(0,i)};const i=document.createElement("style");i.id="ptk-scroll-bar-styles",i.textContent="\n      <style>\n        html::-webkit-scrollbar, \n        body::-webkit-scrollbar {\n          width: 0px;\n        }\n\n        html, body {\n          scrollbar-width: none;\n        }\n      </style>\n    ",document.head.appendChild(i);const n=(t,s,i)=>{const n=window.innerHeight,o=i.y.end-i.y.start,r=n/o*n,h=3+t.y*o+t.y*(n-6-r);e.style.height=`${r}px`,e.style.transform=`translateY(${h}px)`,e.style.willChange="transform",e.style.opacity="1",c()};t.onProgress(n),n(t.getProgress(),t.getCurrent(),t.getBounds())}},$=class{constructor({root:t=document.body,lerp:s=.25,offsets:e=[0,0],plugins:i=[]}){this._lerp=.25,this._slowLerp=.1,this._offsets=[0,0,0,0],this._triggers=new Map,this._plugins=[],this._progressListeners=[],this._saveScroll=()=>{window.scrollTo(this.current.x.getCurrent(),this.current.y.getCurrent())},this._onScroll=t=>{t.preventDefault(),this.current.y.setTarget(window.scrollY,this._lerp)},this._onResize=()=>{document.documentElement.style.setProperty("--vh",.01*window.innerHeight+"px"),document.documentElement.style.height=document.body.scrollHeight+"px",this.current.x.setBounds(0,this._root.offsetWidth-window.innerWidth),this.current.y.setBounds(0,this._root.offsetHeight-window.innerHeight),this._applyScroll(),this._updateTriggers()},this._applyScroll=()=>{const t=this.getCurrent();document.body.style.transform=`translate3d(${t.x}px, ${-t.y}px, 0)`,this._progressListeners.forEach((t=>t(this.getProgress(),this.getCurrent(),this.getBounds())))},this._handleIntersection=t=>{t.forEach((t=>{const s=this._triggers.get(t.target);s&&s.forEach((s=>{s.active=t.isIntersecting,s.entry=t}))}))},this._updateTriggers=()=>{this._triggers.forEach((t=>{t.forEach((t=>{(t.active||t.forever)&&t.callback(t)(this)}))}))},this._root=t,document.documentElement.style.height=document.body.scrollHeight+"px",document.body.style.position="fixed",this._lerp=s,this._offsets=this._formatOffset(e),this.current={x:new a(window.scrollX,s),y:new a(window.scrollY,s)},this._onResize(),this._applyScroll(),window.addEventListener("scroll",this._onScroll),window.addEventListener("resize",this._onResize),window.addEventListener("beforeunload",this._saveScroll),new ResizeObserver(this._onResize).observe(this._root),this._observer=new IntersectionObserver(this._handleIntersection),requestAnimationFrame(this._animate.bind(this)),this._plugins=i,this._plugins.forEach((t=>t(this))),document.body.style.visibility="visible"}_animate(){(this.current.x.shouldTick()||this.current.y.shouldTick())&&(this.current.x.tick(),this.current.y.tick(),this._applyScroll(),this._updateTriggers()),requestAnimationFrame(this._animate.bind(this))}_formatOffset(t){return"number"==typeof t?[t,t,t,t]:Array.isArray(t)&&2===t.length?[t[0],t[1],t[0],t[1]]:t}getRoot(){return this._root}getOffsets(){return this._offsets}getProgress(){return{x:this.current.x.getProgress(),y:this.current.y.getProgress()}}getCurrent(){return{x:this.current.x.getCurrent(),y:this.current.y.getCurrent()}}getTarget(){return{x:this.current.x.getTarget(),y:this.current.y.getTarget()}}getBounds(){return{x:this.current.x.getBounds(),y:this.current.y.getBounds()}}scrollXTo(t,{offset:s=0,lerp:e=this._slowLerp}={}){this.current.x.setTarget("number"==typeof t?t+s:t.getBoundingClientRect().left+this.current.x.getCurrent()+s,e)}scrollYTo(t,{offset:s=0,lerp:e=this._slowLerp}={}){this.current.y.setTarget("number"==typeof t?t+s:t.getBoundingClientRect().top+this.current.y.getCurrent()+s,e)}trigger(t,s,e){const i={element:t,active:!1,forever:e?.forever,entry:null,opts:{...e,offset:this._formatOffset(e?.offset)},callback:s};this._observer.observe(t),this._triggers.set(t,this._triggers.get(t)||[]),this._triggers.get(t)?.push(i),i.callback(i)(this)}onProgress(t){this._progressListeners.push(t)}};