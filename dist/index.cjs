"use strict";function t(t){t.intersection=(s,i)=>{t.trigger(s,function(t){return s=>i=>{const{element:e}=s,h=e.getBoundingClientRect(),{width:r,height:n,top:o,left:a}=h,c=window.innerHeight,l=i.getCurrent().y,p=s.opts.offset||i.getOffsets(),d=p[1]*c,x=p[3]*c,f=(0,u.clamp)(0,-a/r,1),w=(0,u.clamp)(0,-(o-d)/n,1),y=(e.offsetTop-(l+c-x))/n,g=1+(e.offsetTop-(l+d))/n,b=Math.min(n,c-(d+x))/n,m=(0,u.clamp)(0,Math.min(-y,Math.min(b,g)),1);t({intersection:{x:f,y:w||-(0,u.clamp)(0,1-(l+c-e.offsetTop-x)/n,1)},overlapping:{x:1-Math.abs(f),y:m},bb:h})}}(i))}}function s(t){function s(t){const s=Object.assign({willChange:!0},t.opts),i=s.willChange;return s.parent&&(s.parent.style.position="relative"),i&&(t.element.style.willChange.includes("transform")||(t.element.style.willChange+=" transform")),t.element.oldTransform||(t.element.oldTransform=d(t.element.style.transform)),i=>{const{element:e}=t,h=s.parent||i.getRoot(),r=(s.offset||i.getOffsets())[1]*window.innerHeight,n=e.offsetTop+h.offsetTop+e.oldTransform.y,o=h.offsetTop+(h.offsetHeight-r)-e.offsetHeight;let a=n-r-i.getCurrent().y;a=Math.min(a,0),a-=Math.min(0,o-i.getCurrent().y);let c=0;c=-a;const l=g({x:0,y:c},e.oldTransform,!1);e.style.transform=`translate3D(${l.x}px, ${l.y}px, 0px)`}}t.sticky=(i,e)=>{t.trigger(i,s,e)}}function i(t){function s(t){const{speed:s=1,centered:i=!0}=t.opts||{};return e=>{const{element:h}=t,r=e.getCurrent().y,n=i?(h.offsetTop-r-window.innerHeight/2)*s:r*s;h.style.transform=`translate3D(0, ${n}px, 0)`}}t.speed=(i,e)=>{t.trigger(i,s,{...e,forever:!0})}}function e(t){function s(t){const{invert:s=!1,target:i}=t.opts||{};return t.element.style.willChange&&(t.element.style.willChange=t.element.style.willChange+" clipPath"),e=>{const{element:h}=t,r=h.offsetTop,n=i.parentElement.offsetTop,o=window.innerHeight,a=i.offsetHeight,c=e.getOffsets(),l=d(i.style.transform),u=c[1]*o-l.y,p=c[3]*o-l.y,x=i.offsetTop-r-e.getCurrent().y+n-u,f=i.offsetTop+i.offsetHeight-e.getCurrent().y+n-p;if(s){const t=`polygon(0 ${x}px,100% ${x}px,100% ${x+a}px,0 ${x+a}px)`;h.style.clipPath=t}else{const t=`polygon(0% 0%,0 ${x}px,0 ${f}px,0 ${x}px,100% ${x}px,100% ${f}px,0 ${f}px,0 100%,100% 100%,100% 0%)`;h.style.clipPath=t}}}t.mask=(i,e,h=!1)=>{t.trigger(i,s,{target:e,invert:h,forever:!0})}}function h(t={scrollBar:{},scrollBarThumb:{}}){const s={scrollBar:{position:"fixed",zIndex:2e3,top:0,right:"1px",width:"10px",height:"100%",...t.scrollBar},scrollBarThumb:{position:"absolute",top:0,left:0,width:"calc(100% - 4px)",height:"calc(100% - 2px)",backgroundColor:"#babac0",borderRadius:"10px",marginLeft:"2px",boxShadow:"0 0 10px 0 rgba(0, 0, 0, 0.2)",transition:"opacity 0.5s ease-in-out",opacity:0,...t.scrollBarThumb}},i=`<div id="ptk-scroll-bar" style="${b(s.scrollBar)}">\n    <div class="ptk-scroll-bar-thumb" style="${b(s.scrollBarThumb)}"></div>\n  </div>`;return document.body.insertAdjacentHTML("beforeend",i),function(t){const s=document.querySelector("#ptk-scroll-bar"),i=s?.querySelector(".ptk-scroll-bar-thumb"),e=(0,u.debounce)((()=>{i.style.opacity="0.1"}),1e3),h=(t,s,h)=>{const r=window.innerHeight,n=h.y.end-h.y.start,o=r/n*r,a=3+t.y*n+t.y*(r-6-o);i.style.height=`${o}px`,i.style.transform=`translateY(${a}px)`,i.style.willChange="transform",i.style.opacity="1",e()};t.onProgress(h),h(t.getProgress(),t.getCurrent(),t.getBounds())}}var r,n=Object.defineProperty,o=Object.getOwnPropertyDescriptor,a=Object.getOwnPropertyNames,c=Object.prototype.hasOwnProperty,l={};((t,s)=>{for(var i in s)n(t,i,{get:s[i],enumerable:!0})})(l,{default:()=>m,intersection:()=>t,mask:()=>e,scrollBar:()=>h,speed:()=>i,sticky:()=>s}),module.exports=(r=l,((t,s,i,e)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let i of a(s))c.call(t,i)||undefined===i||n(t,i,{get:()=>s[i],enumerable:!(e=o(s,i))||e.enumerable});return t})(n({},"__esModule",{value:!0}),r));var u=require("@petitkit/utils"),p=class{constructor(t,s=.25){this._bounds={start:0,end:0},this._inertia=0,this._values=[],this._current=t,this._target=t,this._lerp=s,this._originLerp=s}shouldTick(){const t=this._current-(this._target+this._inertia);return Math.abs(t)>.1}setCurrent(t){this._current=t}setBounds(t,s){this._bounds={start:t,end:s},this._current=(0,u.clamp)(this._bounds.start,this._current,this._bounds.end),this._target=(0,u.clamp)(this._bounds.start,this._target,this._bounds.end)}setTarget(t,s=this._originLerp){this._target=(0,u.clamp)(this._bounds.start,t,this._bounds.end),this._lerp=s}setDelta(t,s=this._originLerp){this.setTarget(this._target+t,s)}tick(){return this._inertia*=.955,this._target+=this._inertia,this._current+=(this._target-this._current)*this._lerp,this._current=(0,u.clamp)(this._bounds.start,this._current,this._bounds.end),this._current}resetInertia(){this._inertia=0,this._values=[]}incrementInertia(t){this._values.push(t),this._values.length>20&&this._values.shift()}computeInertia(){this._inertia=this._values.length?(0,u.sum)(this._values)/this._values.length:0}getTarget(){return this._target}getCurrent(){return this._current}getBounds(){return this._bounds}getProgress(){return this._current/(this._bounds.end-this._bounds.start)||0}},d=t=>t.includes("translate3d")?x(t):t.includes("translate")?f(t):t.includes("translateX")?w(t):t.includes("translateY")?y(t):{x:0,y:0},x=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate3d(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},f=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},w=t=>({x:parseFloat(t.replace("translateX(","")),y:0}),y=t=>({x:0,y:parseFloat(t.replace("translateY(",""))}),g=(t,s,i=!1)=>({x:t.x+(i?-s.x:s.x),y:t.y+(i?-s.y:s.y)}),b=t=>Object.entries(t).map((([t,s])=>`${t.replace(/([A-Z])/g,"-$1").toLowerCase()}: ${s}`)).join(";"),m=class{constructor({root:t=document.body,lerp:s=.25,slowLerp:i=.1,offset:e=[0,0],plugins:h=[]}={}){this._target={x:new p(0),y:new p(0)},this._current={x:0,y:0},this._touchStart={x:0,y:0},this._touchDelta={x:0,y:0},this._offsets=[0,0,0,0],this._triggers=new Map,this._plugins=[],this._progressListeners=[],this._willSaveScroll=!0,this._slowLerp=.1,this._onResize=()=>{this._target.x.setBounds(0,this._root.offsetWidth-window.innerWidth),this._target.y.setBounds(0,this._root.offsetHeight-window.innerHeight),this._applyScroll(),this._updateTriggers()},this._onWheel=t=>{t.preventDefault(),this._target.x.setDelta(t.deltaX),this._target.y.setDelta(t.deltaY)},this._onTouchStart=t=>{t.preventDefault(),this._touchStart={x:t.touches[0].clientX,y:t.touches[0].clientY},this._touchDelta={x:0,y:0},this._target.x.resetInertia(),this._target.y.resetInertia()},this._onTouchMove=t=>{t.preventDefault(),this._touchDelta={x:this._touchStart.x-t.touches[0].clientX,y:this._touchStart.y-t.touches[0].clientY},this._touchStart={x:t.touches[0].clientX,y:t.touches[0].clientY},["x","y"].forEach((t=>{this._target[t].setDelta(this._touchDelta[t]),this._target[t].incrementInertia(this._touchDelta[t])}))},this._onTouchEnd=t=>{t.preventDefault(),0===this._touchDelta.x&&0===this._touchDelta.y||(t.stopImmediatePropagation(),t.stopPropagation(),t.preventDefault()),this._target.x.computeInertia(),this._target.y.computeInertia()},this._onKeyDown=t=>{const s=window.innerHeight,i=t.metaKey||t.ctrlKey,e={ArrowUp:[0,-.25*s],ArrowDown:[0,.25*s],ArrowLeft:[-.25*s,0],ArrowRight:[.25*s,0],Space:[0,.5*s*(t.shiftKey?-1:1)]};"ArrowUp"===t.code&&i&&this._target.y.setTarget(0,this._slowLerp),"ArrowDown"===t.code&&i&&this._target.y.setTarget(this._target.y.getBounds().end,this._slowLerp),e[t.code]&&(t.preventDefault(),this._target.x.setDelta(e[t.code][0],this._slowLerp),this._target.y.setDelta(e[t.code][1],this._slowLerp)),"KeyR"===t.code&&t.metaKey&&t.shiftKey&&(this._willSaveScroll=!1)},this._handleIntersection=t=>{t.forEach((t=>{const s=this._triggers.get(t.target);s&&s.forEach((s=>{s.active=t.isIntersecting,s.entry=t}))}))},this._updateTriggers=()=>{this._triggers.forEach((t=>{t.forEach((t=>{(t.active||t.forever)&&t.callback(t)(this)}))}))},this._animate=()=>{0!==window.scrollY&&window.scrollTo(0,0),(this._target.x.shouldTick()||this._target.y.shouldTick())&&(this._target.x.tick(),this._target.y.tick(),this._applyScroll(),this._updateTriggers()),requestAnimationFrame(this._animate)},this._applyScroll=()=>{this._current={x:this._target.x.getCurrent(),y:this._target.y.getCurrent()},this._progressListeners.forEach((t=>t(this.getProgress(),this.getCurrent(),this.getBounds()))),this._root.style.transform=`translate3D(${this._current.x}px, ${-this._current.y}px, 0)`},this._saveScroll=()=>{let t=this._willSaveScroll?{scrollX:Math.floor(this._target.x.getCurrent())||0,scrollY:Math.floor(this._target.y.getCurrent())||0,targetX:Math.floor(this._target.x.getTarget())||0,targetY:Math.floor(this._target.y.getTarget())||0}:{};history.replaceState(t,document.title)},window.scrollTo(0,0),document.documentElement.style.overflow="hidden",history.scrollRestoration="auto";const{scrollX:r=0,scrollY:n=0,targetX:o=0,targetY:a=0}=history.state||{};this._root=t,this._slowLerp=i,this._offsets=this._formatOffset(e),this._target={x:new p(r,s),y:new p(n,s)},this._current={x:r,y:n},this._onResize(),this._target.x.setTarget(o),this._target.y.setTarget(a),this._applyScroll();const c=[["wheel",this._onWheel],["keydown",this._onKeyDown],["touchstart",this._onTouchStart],["touchmove",this._onTouchMove],["touchend",this._onTouchEnd],["resize",this._onResize],["beforeunload",this._saveScroll],["DOMContentLoaded",()=>{this._onResize(),this._target.x.setCurrent(r),this._target.y.setCurrent(n),this._target.x.setTarget(o),this._target.y.setTarget(a),this._applyScroll()}]];new ResizeObserver(this._onResize).observe(this._root),c.forEach((([t,s])=>window.addEventListener(t,s,{passive:!1}))),this._observer=new IntersectionObserver(this._handleIntersection),requestAnimationFrame(this._animate),this._plugins=h,this._plugins.forEach((t=>t(this))),document.body.style.visibility="visible";let l=0;document.addEventListener("touchend",(function(t){const s=(new Date).getTime();s-l<=300&&t.preventDefault(),l=s}),{passive:!1})}_formatOffset(t){return"number"==typeof t?[t,t,t,t]:Array.isArray(t)&&2===t.length?[t[0],t[1],t[0],t[1]]:t}getCurrent(){return this._current}getOffsets(){return this._offsets}getRoot(){return this._root}getProgress(){return{x:this._target.x.getProgress(),y:this._target.y.getProgress()}}getBounds(){return{x:this._target.x.getBounds(),y:this._target.y.getBounds()}}scrollTo(t,{offset:s=0,lerp:i=this._slowLerp}={}){this._target.y.setTarget("number"==typeof t?t+s:t.getBoundingClientRect().top+this._target.y.getCurrent()+s,i)}trigger(t,s,i){const e={element:t,active:!1,forever:i?.forever,entry:null,opts:{...i,offset:this._formatOffset(i?.offset)},callback:s};this._observer.observe(t),this._triggers.set(t,this._triggers.get(t)||[]),this._triggers.get(t)?.push(e),e.callback(e)(this)}onProgress(t){this._progressListeners.push(t)}};