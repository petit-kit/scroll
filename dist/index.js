function t(t){t.intersection=(s,i)=>{t.trigger(s,function(t){return s=>i=>{const{element:h}=s,e=h.getBoundingClientRect(),{width:n,height:o,top:a,left:c}=e,l=window.innerHeight,u=i.getCurrent().y,p=s.opts.offset||i.getOffsets(),d=p[1]*l,x=p[3]*l,w=r(0,-c/n,1),f=r(0,-(a-d)/o,1),y=(h.offsetTop-(u+l-x))/o,g=1+(h.offsetTop-(u+d))/o,m=Math.min(o,l-(d+x))/o,b=r(0,Math.min(-y,Math.min(m,g)),1);t({intersection:{x:w,y:f||-r(0,1-(u+l-h.offsetTop-x)/o,1)},overlapping:{x:1-Math.abs(w),y:b},bb:e})}}(i))}}function s(t){function s(t){const s=Object.assign({willChange:!0},t.opts),i=s.willChange;return s.parent&&(s.parent.style.position="relative"),i&&(t.element.style.willChange.includes("transform")||(t.element.style.willChange+=" transform")),t.element.oldTransform||(t.element.oldTransform=c(t.element.style.transform)),i=>{const{element:h}=t,e=s.parent||i.getRoot(),r=(s.offset||i.getOffsets())[1]*window.innerHeight,n=h.offsetTop+e.offsetTop+h.oldTransform.y,o=e.offsetTop+(e.offsetHeight-r)-h.offsetHeight;let a=n-r-i.getCurrent().y;a=Math.min(a,0),a-=Math.min(0,o-i.getCurrent().y);let c=0;c=-a;const l=((t,s,i=!1)=>({x:t.x+(i?-s.x:s.x),y:t.y+(i?-s.y:s.y)}))({x:0,y:c},h.oldTransform,!1);h.style.transform=`translate3D(${l.x}px, ${l.y}px, 0px)`}}t.sticky=(i,h)=>{t.trigger(i,s,h)}}function i(t){function s(t){const{speed:s=1,centered:i=!0}=t.opts||{};return h=>{const{element:e}=t,r=h.getCurrent().y,n=i?(e.offsetTop-r-window.innerHeight/2)*s:r*s;e.style.transform=`translate3D(0, ${n}px, 0)`}}t.speed=(i,h)=>{t.trigger(i,s,{...h,forever:!0})}}function h(t){function s(t){const{invert:s=!1,target:i}=t.opts||{};return t.element.style.willChange&&(t.element.style.willChange=t.element.style.willChange+" clipPath"),h=>{const{element:e}=t,r=e.offsetTop,n=i.parentElement.offsetTop,o=window.innerHeight,a=i.offsetHeight,l=h.getOffsets(),u=c(i.style.transform),p=l[1]*o-u.y,d=l[3]*o-u.y,x=i.offsetTop-r-h.getCurrent().y+n-p,w=i.offsetTop+i.offsetHeight-h.getCurrent().y+n-d;if(s){const t=`polygon(0 ${x}px,100% ${x}px,100% ${x+a}px,0 ${x+a}px)`;e.style.clipPath=t}else{const t=`polygon(0% 0%,0 ${x}px,0 ${w}px,0 ${x}px,100% ${x}px,100% ${w}px,0 ${w}px,0 100%,100% 100%,100% 0%)`;e.style.clipPath=t}}}t.mask=(i,h,e=!1)=>{t.trigger(i,s,{target:h,invert:e,forever:!0})}}function e(t={scrollBar:{},scrollBarThumb:{}}){const s={scrollBar:{position:"fixed",zIndex:2e3,top:0,right:"1px",width:"10px",height:"100%",...t.scrollBar},scrollBarThumb:{position:"absolute",top:0,left:0,width:"calc(100% - 4px)",height:"calc(100% - 2px)",backgroundColor:"#babac0",borderRadius:"10px",marginLeft:"2px",boxShadow:"0 0 10px 0 rgba(0, 0, 0, 0.2)",transition:"opacity 0.5s ease-in-out",opacity:0,...t.scrollBarThumb}},i=`<div id="ptk-scroll-bar" style="${x(s.scrollBar)}">\n    <div class="ptk-scroll-bar-thumb" style="${x(s.scrollBarThumb)}"></div>\n  </div>`;return document.body.insertAdjacentHTML("beforeend",i),function(t){const s=document.querySelector("#ptk-scroll-bar"),i=s?.querySelector(".ptk-scroll-bar-thumb"),h=o((()=>{i.style.opacity="0.1"}),1e3),e=(t,s,e)=>{const r=window.innerHeight,n=e.y.end-e.y.start,o=r/n*r,a=3+t.y*n+t.y*(r-6-o);i.style.height=`${o}px`,i.style.transform=`translateY(${a}px)`,i.style.willChange="transform",i.style.opacity="1",h()};t.onProgress(e),e(t.getProgress(),t.getCurrent(),t.getBounds())}}import{clamp as r,sum as n,debounce as o}from"@petitkit/utils";var a=class{constructor(t,s=.25){this._bounds={start:0,end:0},this._inertia=0,this._values=[],this._current=t,this._target=t,this._lerp=s,this._originLerp=s}shouldTick(){const t=this._current-(this._target+this._inertia);return Math.abs(t)>.1}setCurrent(t){this._current=t}setBounds(t,s){this._bounds={start:t,end:s},this._current=r(this._bounds.start,this._current,this._bounds.end),this._target=r(this._bounds.start,this._target,this._bounds.end)}setTarget(t,s=this._originLerp){this._target=r(this._bounds.start,t,this._bounds.end),this._lerp=s}setDelta(t,s=this._originLerp){this.setTarget(this._target+t,s)}tick(){return this._inertia*=.955,this._target+=this._inertia,this._current+=(this._target-this._current)*this._lerp,this._current=r(this._bounds.start,this._current,this._bounds.end),this._current}resetInertia(){this._inertia=0,this._values=[]}incrementInertia(t){this._values.push(t),this._values.length>20&&this._values.shift()}computeInertia(){this._inertia=this._values.length?n(this._values)/this._values.length:0}getTarget(){return this._target}getCurrent(){return this._current}getBounds(){return this._bounds}getProgress(){return this._current/(this._bounds.end-this._bounds.start)||0}},c=t=>t.includes("translate3d")?l(t):t.includes("translate")?u(t):t.includes("translateX")?p(t):t.includes("translateY")?d(t):{x:0,y:0},l=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate3d(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},u=t=>{if(!t)return{x:0,y:0};const s=t.replace("translate(","").split(",").map((t=>parseFloat(t)));return{x:s[0],y:s[1]}},p=t=>({x:parseFloat(t.replace("translateX(","")),y:0}),d=t=>({x:0,y:parseFloat(t.replace("translateY(",""))}),x=t=>Object.entries(t).map((([t,s])=>`${t.replace(/([A-Z])/g,"-$1").toLowerCase()}: ${s}`)).join(";"),w=class{constructor({root:t=document.body,lerp:s=.25,slowLerp:i=.1,offset:h=[0,0],plugins:e=[]}={}){this._target={x:new a(0),y:new a(0)},this._current={x:0,y:0},this._touchStart={x:0,y:0},this._touchDelta={x:0,y:0},this._offsets=[0,0,0,0],this._triggers=new Map,this._plugins=[],this._progressListeners=[],this._willSaveScroll=!0,this._slowLerp=.1,this._onResize=()=>{this._target.x.setBounds(0,this._root.offsetWidth-window.innerWidth),this._target.y.setBounds(0,this._root.offsetHeight-window.innerHeight),this._applyScroll(),this._updateTriggers()},this._onWheel=t=>{t.preventDefault(),this._target.x.setDelta(t.deltaX),this._target.y.setDelta(t.deltaY)},this._onTouchStart=t=>{t.preventDefault(),this._touchStart={x:t.touches[0].clientX,y:t.touches[0].clientY},this._touchDelta={x:0,y:0},this._target.x.resetInertia(),this._target.y.resetInertia()},this._onTouchMove=t=>{t.preventDefault(),this._touchDelta={x:this._touchStart.x-t.touches[0].clientX,y:this._touchStart.y-t.touches[0].clientY},this._touchStart={x:t.touches[0].clientX,y:t.touches[0].clientY},["x","y"].forEach((t=>{this._target[t].setDelta(this._touchDelta[t]),this._target[t].incrementInertia(this._touchDelta[t])}))},this._onTouchEnd=t=>{t.preventDefault(),0===this._touchDelta.x&&0===this._touchDelta.y||(t.stopImmediatePropagation(),t.stopPropagation(),t.preventDefault()),this._target.x.computeInertia(),this._target.y.computeInertia()},this._onKeyDown=t=>{const s=window.innerHeight,i=t.metaKey||t.ctrlKey,h={ArrowUp:[0,-.25*s],ArrowDown:[0,.25*s],ArrowLeft:[-.25*s,0],ArrowRight:[.25*s,0],Space:[0,.5*s*(t.shiftKey?-1:1)]};"ArrowUp"===t.code&&i&&this._target.y.setTarget(0,this._slowLerp),"ArrowDown"===t.code&&i&&this._target.y.setTarget(this._target.y.getBounds().end,this._slowLerp),h[t.code]&&(t.preventDefault(),this._target.x.setDelta(h[t.code][0],this._slowLerp),this._target.y.setDelta(h[t.code][1],this._slowLerp)),"KeyR"===t.code&&t.metaKey&&t.shiftKey&&(this._willSaveScroll=!1)},this._handleIntersection=t=>{t.forEach((t=>{const s=this._triggers.get(t.target);s&&s.forEach((s=>{s.active=t.isIntersecting,s.entry=t}))}))},this._updateTriggers=()=>{this._triggers.forEach((t=>{t.forEach((t=>{(t.active||t.forever)&&t.callback(t)(this)}))}))},this._animate=()=>{0!==window.scrollY&&window.scrollTo(0,0),(this._target.x.shouldTick()||this._target.y.shouldTick())&&(this._target.x.tick(),this._target.y.tick(),this._applyScroll(),this._updateTriggers()),requestAnimationFrame(this._animate)},this._applyScroll=()=>{this._current={x:this._target.x.getCurrent(),y:this._target.y.getCurrent()},this._progressListeners.forEach((t=>t(this.getProgress(),this.getCurrent(),this.getBounds()))),this._root.style.transform=`translate3D(${this._current.x}px, ${-this._current.y}px, 0)`},this._saveScroll=()=>{let t=this._willSaveScroll?{scrollX:Math.floor(this._target.x.getCurrent())||0,scrollY:Math.floor(this._target.y.getCurrent())||0,targetX:Math.floor(this._target.x.getTarget())||0,targetY:Math.floor(this._target.y.getTarget())||0}:{};history.replaceState(t,document.title)},window.scrollTo(0,0),document.documentElement.style.overflow="hidden",history.scrollRestoration="auto";const{scrollX:r=0,scrollY:n=0,targetX:o=0,targetY:c=0}=history.state||{};this._root=t,this._slowLerp=i,this._offsets=this._formatOffset(h),this._target={x:new a(r,s),y:new a(n,s)},this._current={x:r,y:n},this._onResize(),this._target.x.setTarget(o),this._target.y.setTarget(c),this._applyScroll();const l=[["wheel",this._onWheel],["keydown",this._onKeyDown],["touchstart",this._onTouchStart],["touchmove",this._onTouchMove],["touchend",this._onTouchEnd],["resize",this._onResize],["beforeunload",this._saveScroll],["DOMContentLoaded",()=>{this._onResize(),this._target.x.setCurrent(r),this._target.y.setCurrent(n),this._target.x.setTarget(o),this._target.y.setTarget(c),this._applyScroll()}]];new ResizeObserver(this._onResize).observe(this._root),l.forEach((([t,s])=>window.addEventListener(t,s,{passive:!1}))),this._observer=new IntersectionObserver(this._handleIntersection),requestAnimationFrame(this._animate),this._plugins=e,this._plugins.forEach((t=>t(this))),document.body.style.visibility="visible";let u=0;document.addEventListener("touchend",(function(t){const s=(new Date).getTime();s-u<=300&&t.preventDefault(),u=s}),{passive:!1})}_formatOffset(t){return"number"==typeof t?[t,t,t,t]:Array.isArray(t)&&2===t.length?[t[0],t[1],t[0],t[1]]:t}getCurrent(){return this._current}getOffsets(){return this._offsets}getRoot(){return this._root}getProgress(){return{x:this._target.x.getProgress(),y:this._target.y.getProgress()}}getBounds(){return{x:this._target.x.getBounds(),y:this._target.y.getBounds()}}scrollTo(t,{offset:s=0,lerp:i=this._slowLerp}={}){this._target.y.setTarget("number"==typeof t?t+s:t.getBoundingClientRect().top+this._target.y.getCurrent()+s,i)}trigger(t,s,i){const h={element:t,active:!1,forever:i?.forever,entry:null,opts:{...i,offset:this._formatOffset(i?.offset)},callback:s};this._observer.observe(t),this._triggers.set(t,this._triggers.get(t)||[]),this._triggers.get(t)?.push(h),h.callback(h)(this)}onProgress(t){this._progressListeners.push(t)}};export{w as default,t as intersection,h as mask,e as scrollBar,i as speed,s as sticky};